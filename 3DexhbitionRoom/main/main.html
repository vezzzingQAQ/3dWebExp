<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D展览馆</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body{
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
    </style>
    <script src="../support/p5.min.js"></script>
    <script src="objects.js"></script>
    <script>
        var player;
        function setup() {
            createCanvas(windowWidth,windowHeight,WEBGL);
            smooth();
            class Player{
                constructor(player,objects){
                    this.x=player.startPosition.x;
                    this.y=player.startPosition.y;
                    this.z=player.startPosition.z+player.height/2;
                    this.height=player.height;
                    this.originHeight=player.height;
                    this.moveSpeed=player.moveSpeed;
                    this.moveHeightRange=player.moveHeightRange;
                    this.bumpR=player.bumpR;
                    this.objectsList=objects;
                }
                _calBump(x,z,cube){//返回x,z位置坐标的值
                    if(cube.hasOwnProperty("bump") && cube.position.y+cube.bump.size.y/2>(this.y+player.height)/2){
                        let leftBound=cube.position.x-cube.bump.size.x/2-this.bumpR;
                        let rightBound=cube.position.x+cube.bump.size.x/2+this.bumpR;
                        let upperBound=cube.position.z+cube.bump.size.z/2+this.bumpR;
                        let lowerBound=cube.position.z-cube.bump.size.z/2-this.bumpR;
                        if((x<rightBound && x>leftBound) && (z<upperBound && z>lowerBound)){
                            let distLeftBound=abs(x-leftBound);
                            let distRightBound=abs(x-rightBound);
                            let distUpperBound=abs(z-upperBound);
                            let distLowerBound=abs(z-lowerBound);
                            let minDist=(min(distLeftBound,distRightBound,distUpperBound,distLowerBound));
                            console.log(minDist);
                            if(minDist==distLeftBound){
                                return({x:leftBound,z:z});
                            }else if(minDist==distRightBound){
                                return({x:rightBound,z:z});
                            }else if(minDist==distUpperBound){
                                return({x:x,z:upperBound});
                            }else{
                                return({x:x,z:lowerBound});
                            }
                        }else{
                            return({x:x,z:z});
                        }
                    }else{
                        return({x:x,z:z});
                    }
                }
                _walk(){
                    for(let i=0;i<this.objectsList.length;i++){
                        let newPosition=this._calBump(this.x,this.z,this.objectsList[i]);
                        this.x=newPosition.x;
                        this.z=newPosition.z;
                    }
                    this.height=this.originHeight+sin(frameCount/10)*this.moveHeightRange;
                }
                walkForward(){
                    this.x+=this.moveSpeed*cos(this.thetarw);
                    this.z-=this.moveSpeed*sin(this.thetarw);
                    this._walk();
                }
                walkBackward(){
                    this.x-=this.moveSpeed*cos(this.thetarw);
                    this.z+=this.moveSpeed*sin(this.thetarw);
                    this._walk();
                }
                walkLeft(){
                    this.x+=this.moveSpeed*sin(this.thetarw);
                    this.z+=this.moveSpeed*cos(this.thetarw);
                    this._walk();
                }
                walkRight(){
                    this.x-=this.moveSpeed*sin(this.thetarw);
                    this.z-=this.moveSpeed*cos(this.thetarw);
                    this._walk();
                }
                lookAround(){
                    camera(this.x,this.y+this.height,this.z,
                    this.x+100*cos(this.thetarw),
                    this.y+this.height-100*sin(this.thetaeh),
                    this.z-100*sin(this.thetarw),
                    0,-1,0);
                }
                update(){
                    //鼠标转向
                    this.thetarw=map(mouseX,width,0,2*PI,0);
                    this.thetaeh=map(mouseY,0,height,-PI/2,PI/2);
                    //走路
                    if(keyIsPressed){
                        if(keyCode==87){
                            this.walkForward();
                        }else if(keyCode==83){
                            this.walkBackward();
                        }else if(keyCode==65){
                            this.walkLeft();
                        }else if(keyCode==68){
                            this.walkRight();
                        }
                        
                    }
                    this.lookAround();
                }
            }
            player=new Player(objects.player,objects.objectsList);
        }
        function windowResized(){
            resizeCanvas(windowWidth,windowHeight);
        }
        function draw(){
            background(0);
            //渲染场景中的每个物体
            for(let i=0;i<objects.objectsList.length;i++){
                let currentObject=objects.objectsList[i];
                if(currentObject.type==1){
                    push();
                        if(currentObject.stroke!=null){
                            stroke.apply(null,currentObject.stroke);
                        }else{
                            noStroke();
                        }
                        if(currentObject.fill!=null){
                            fill.apply(null,currentObject.fill);
                        }else{
                            noFill();
                        }
                        translate(currentObject.position.x,currentObject.position.y,currentObject.position.z);
                        box(currentObject.size.x,currentObject.size.y,currentObject.size.z);
                    pop();
                }
            }
            //加入玩家视角
            player.update();
        }
    </script>
</head>
<body>
    
</body>
</html>